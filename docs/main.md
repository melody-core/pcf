<!--
 * @Author: 六弦(melodyWxy)
 * @Date: 2022-09-26 10:37:35
 * @LastEditors: 六弦(melodyWxy)
 * @LastEditTime: 2022-09-26 16:28:10
 * @FilePath: /melodyLCP/test1.md
 * @Description: update here
-->

# melodyLCP

## 概念

我们将含有完整业务逻辑的应用程序进行拆解，认为构成其的核心在于模型与页面。

### 模型

对于开发一个应用来讲，我们首先会基于业务逻辑来抽象库表模型，通过表字段关联来耦合业务逻辑的关联点。接着围绕库表开发对应的增删改查接口。

### 页面

对于一个完整的应用程序页面而言，可以抽象化为以下特征：

1. UI模板
2. 数据
3. 动作(交互行为)
4. 填充渲染(条件渲染或动态的UI展现)

如图所示，我们认为 UI模板和数据构成了页面主体，而动作和填充渲染属于页面额外的“副作用”。

#### 模板

如果将实际页面作为实例，那么我们可以基于多个具备共同特征的页面，抽离出复用部分，作为一个UI模板。理论上，模板+模型数据+页面独有的业务逻辑特征就能实例出一个页面(例如一个筛选列表页)。
而页面独有的业务逻辑则可以通过 “填充” 和 “动作” 来植入到模板当中。

#### 数据

以上，数据无疑由确定的模型而来。当我们在进行库表建模时，定义对应的字段类型，那么字段对应数据的展示态和编辑态UI便能够确立开来。
例如对于一个学生管理模块来进行建模:

```ts
{
  id: string,
  name: string,
  age: number,
  class: "少儿班ID" | "育红班ID" ,
  // ...others
}
```

那么对于name来讲，string的编辑态暂时可以对应input，而age-number则对应input-number， 而class枚举则可以对应select下拉框。

当然，真实的业务当中，不仅仅要思考到这些，下文中的“模型管理”中我们会有更详尽的描述。

但对于页面所需要的数据来讲，我们大概可以知道这样一张表结构所对应的增删改查接口。

#### 动作

多数业务逻辑是由用户与页面交互进行展示。我们可以将这些交互具象化一个个前端动作: 例如页面跳转、请求接口等。

#### 填充

对于一个通用性的UI模板来讲，对应的实例页面在表现层并不十分一致。比如有的页面在上下区块中间，可能要插入具有页面本身业务特征的UI(例如多一个上传图片的按钮等)。

## 原理

阅读此篇章之前，请确保您已阅读过 “概念”。
为了使您充分理解melodyLCP的“原理”，我们准备了一个demo辅助您去更深入的理解它的底层工作。

### 模型创建-库表的元数据描述

对于一个模型而言，我们认为主体是定义好的库表字段，而字段往往具备一些业务逻辑特征，我们称之为模型字段的“副作用”。
例如：对于一个学生而言，他的性别字段是可枚举的，他的年龄肯定是个区间正整数等。这些副作用会在“页面”中有所体现，包括不限于具体的展示与编辑、接口的校验规则等。
那么，我们以搭建一个学生管理系统为目标，创建我们的第一个模型。
首先，对于一个简单的学生管理系统而言，我们暂时只关注它的核心模块——学生管理模块。
对于学生管理模块而言，我们只关注学生的增删改查。这对应一张学生的库表，也就是我们要创建的第一个模型。
如图所示，创建模型分为两步:

1. 定义模型的名称和描述;
注意: 我们要求对模型进行一个模型名称的定义，它具备实际的意义————对应创建出的库表名称，因此对于一个应用程序而言，它是唯一的。对于这种描述学生的表而言，我们暂时将其命名为 XStudent;
2. 定义模型的字段与字段对应的副作用设置;
当我们点击完成时，一份用以描述Student库表的”模型元数据“(用来描述模型数据的数据)就诞生了。你可以将其理解为一个这样的JSON(尽管是简化后的):

```json
{
  "id": "xxxx", // 模型id
  "name": "Student", //模型名称
  "desc": "一段可有可无的描述", //模型描述
  "status": 1, // 正常使用的
  "filed": [{  // 库表字段描述
    "name": "name", // 字段名
    "type": "text", // 字段对应的类型, 页面将以此确认它的展示态和编辑态
    "effects": {  //字段的副作用设置
      "popular": { // 字段所具备的通用的副作用设置
        "editAble": true, // 可编辑的
        "Unique": false, // 不是唯一的
        "rules": [{   // 校验规则
          "required": true,
          "message": "学生名字是必须的。"
        }]
      }, 
      "personalized": { // text类型所具备的个性化的副作用设置
        "default": null, // 默认值
      },
      "mock": {
        "type": "string",
        "personalized": {
          "type": "name", // mock为名字形态的数据
          // ...others
        }
      }
    } 
  }, { 
    "name": "age", // 字段名
    "type": "digit", // 字段对应的类型, 页面将以此确认它的展示态和编辑态
    "effects": {  
      "popular": { // 字段所具备的通用的副作用设置
        "editAble": true, // 可编辑的
        "Unique": false, // 不是唯一的
        "rules": [{   // 校验规则
          "required": true,
          "message": "学生年龄是必须的。"
        }]
      }, 
      "personalized": { // text类型所具备的个性化的副作用设置
        "decimal": 0, // 保留小数点后几位，默认全部保留, 0即整数
        "feature": null, // digit专有的枚举特征，例如 美元、人民币等。
        "section": {   // 区间
          "min": {   // >0的设置如下
            "value": 0, // 最小值为0
            "required": false // 并且不包含0
          }   
        }
      },
      "mock": {
        "type": "number",
        "personalized": {
          "type": "int", // mock为整数形态的数据
          // ...others
        }
      }
    } //字段的副作用
  },{
    //...
  }] 
}

```

对于上述的这样一份Schema, melodyLCP在记录它的同时，也会基于它生成对应的库表，以及对应的通用增删改查接口，甚至还会生成mock接口和数据(供给页面的预览效果展示):

+ 单条新增
+ 批量新增
+ 单条查询
+ 批量查询
+ 单条更新
+ 批量更新
+ 单条删除
+ 批量删除

截止到这里，我们在模型侧的处理告一段落。

### 页面创建 - 模板与数据联动

现在，我们来生成对应的页面。
对于学生管理模块而言，我们需要的是学生的查询列表页、新增页、详情页。
那么首先我们来创建查询列表页。

创建页面分为三步，分别为选择模板、绑定模型、绑定副作用(动作+填充)。
如图，我们为页面起个名字“学生管理列表页”，并选择"通用查询列表页模板"，这个模板自带弹窗式的增改，十分满足我们的需求。

如图，我们进行数据模型的绑定，“通用查询列表页模板”对外仅暴露一个模型植入，因此我们仅仅需要在下拉框内选择好我们创建的Student学生模型即可。
模板会业务根据需要调用这个模型对应的增删改查接口，实现数据自由(手动狗头)。
接着我们来植入些副作用，对于学生管理列表而言，我们期望增加一个导出excel表格数据的能力，方便老师们的某些工作。于是，我们选择填充物：导出excel表格按钮。这个填充物是列表通用化的副作用产物，因此我们只需要给这个按钮设置一下名称，而不需要做任何其他多余的事情。

### 预览

截止到这里，一个具备数据交互的完整学生管理模块就被我们创建完了！我们回到页面列表页，对创建的页面进行预览，并开启mock功能。
于是可以看到含有mock数据的页面了！

### 开发应该做的事情

1. 数据核心是模型的定义，这意味着我们要具备对业务抽象的能力。多数情况下，这部分工作由常规意义上的“后端”和部分能力资深的“前端”完成。
2. 页面与模型的结合，关键点在于 模型字段的type定义。这属于melodyLCP的最核心的元组件能力。不断新增“type”，并为之增添effect设置项，是满足一切未知业务逻辑的前提；
3. 页面模板需要具备组件开发能力较强的前端工作者去抽离。这包含了标准化、抽象等多方面的制约，需要彻底理解模板工作的高水平前端来开发和迭代它。
4. 动作相对比较简单，需要一部分函数抽象开发能力，以及对业务逻辑参数的抽象能力。而填充物则是对业务逻辑的复用理解，根据所做的项目，抽离出具备通用且重要的填充UI。某种意义上来讲，填充是可选ui和动作的耦合。

## 进阶

阅读此篇章前，请确保您已阅读过“概念”和“原理”。
进阶会讲解一些更深入的概念如“主数据”、“基础数据”等，以及复杂业务场景需求下的一些处理，包括 “关联”、“多模型”、“嵌套”等场景。
